<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Be My Valentine üíù</title>
  
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Quicksand:wght@300;400;500;600&display=swap" rel="stylesheet">
  
  <!-- Confetti Library -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  
  <style>
    /* ============= RESET & BASE STYLES ============= */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --pink-light: #FFE5EC;
      --pink-medium: #FFB3C6;
      --pink-dark: #FF8FAB;
      --pink-accent: #FF6B9D;
      --white: #FFFFFF;
      --text-dark: #5D3A4A;
      --shadow: rgba(255, 107, 157, 0.3);
    }

    body {
      font-family: 'Quicksand', sans-serif;
      background: linear-gradient(135deg, var(--pink-light) 0%, var(--pink-medium) 100%);
      min-height: 100vh;
      overflow-x: hidden;
      user-select: none;
      -webkit-user-select: none;
      color: var(--text-dark);
    }

    /* ============= FLOATING HEARTS BACKGROUND ============= */
    .floating-hearts {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }

    .floating-heart {
      position: absolute;
      font-size: 20px;
      opacity: 0.6;
      animation: float-up linear infinite;
    }

    @keyframes float-up {
      0% {
        transform: translateY(100vh) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 0.6;
      }
      90% {
        opacity: 0.6;
      }
      100% {
        transform: translateY(-100px) rotate(360deg);
        opacity: 0;
      }
    }

    /* ============= MUSIC CONTROL ============= */
    .music-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: var(--white);
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      box-shadow: 0 4px 15px var(--shadow);
      cursor: pointer;
      font-size: 24px;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .music-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px var(--shadow);
    }

    /* ============= SCENE CONTAINER ============= */
    .scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
      z-index: 10;
      padding: 20px;
    }

    .scene.active {
      opacity: 1;
      visibility: visible;
    }

    .scene-content {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      padding: 40px;
      border-radius: 30px;
      box-shadow: 0 20px 60px rgba(255, 107, 157, 0.2);
      text-align: center;
      max-width: 600px;
      width: 100%;
      animation: slideIn 0.6s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    h1 {
      font-family: 'Playfair Display', serif;
      font-size: 2.5rem;
      color: var(--pink-accent);
      margin-bottom: 20px;
      font-weight: 700;
    }

    p {
      font-size: 1.2rem;
      margin-bottom: 30px;
      line-height: 1.6;
    }

    /* ============= BUTTONS ============= */
    .btn {
      padding: 15px 40px;
      font-size: 1.1rem;
      font-weight: 600;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Quicksand', sans-serif;
      box-shadow: 0 4px 15px var(--shadow);
    }

    .btn-yes {
      background: linear-gradient(135deg, var(--pink-accent), var(--pink-dark));
      color: white;
      margin: 10px;
    }

    .btn-yes:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px var(--shadow);
    }

    .btn-no {
      background: white;
      color: var(--pink-accent);
      margin: 10px;
      position: absolute;
      transition: all 0.2s ease;
    }

    .playful-message {
      margin-top: 20px;
      font-style: italic;
      color: var(--pink-accent);
      min-height: 30px;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* ============= MAZE GAME ============= */
    .maze-container {
      position: relative;
      max-width: 500px;
      margin: 0 auto;
    }

    .maze {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 2px;
      background: var(--pink-medium);
      padding: 10px;
      border-radius: 15px;
      margin: 20px auto;
    }

    .maze-cell {
      aspect-ratio: 1;
      background: white;
      border-radius: 3px;
      position: relative;
    }

    .maze-cell.wall {
      background: var(--pink-dark);
    }

    .maze-cell.path {
      background: white;
    }

    .maze-cell.player {
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }

    .maze-cell.goal {
      background: linear-gradient(135deg, var(--pink-accent), var(--pink-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 1rem;
    }

    .maze-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 15px;
      font-style: italic;
      color: var(--pink-accent);
      box-shadow: 0 4px 15px var(--shadow);
      animation: popIn 0.3s ease;
      pointer-events: none;
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    .controls-hint {
      margin-top: 15px;
      font-size: 0.9rem;
      color: var(--text-dark);
      opacity: 0.7;
    }

    /* ============= HEART CATCHER GAME ============= */
    .game-container {
      position: relative;
      width: 100%;
      max-width: 600px;
      height: 500px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 20px;
      overflow: hidden;
      margin: 20px auto;
    }

    .game-stats {
      display: flex;
      justify-content: space-around;
      margin-bottom: 20px;
      font-size: 1.2rem;
      font-weight: 600;
    }

    .basket {
      position: absolute;
      bottom: 20px;
      width: 80px;
      height: 60px;
      background: var(--pink-accent);
      border-radius: 10px 10px 0 0;
      left: 50%;
      transform: translateX(-50%);
      transition: left 0.1s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
    }

    .falling-heart {
      position: absolute;
      top: -50px;
      font-size: 2rem;
      animation: fall linear;
      cursor: default;
    }

    @keyframes fall {
      to {
        top: 520px;
      }
    }

    /* ============= PUZZLE GAME ============= */
    .puzzle-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 3px;
      max-width: 400px;
      margin: 20px auto;
      background: var(--pink-medium);
      padding: 10px;
      border-radius: 15px;
    }

    .puzzle-tile {
      aspect-ratio: 1;
      background-size: 400% 400%;
      background-color: white;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: var(--text-dark);
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    .puzzle-tile:hover:not(.empty) {
      transform: scale(1.05);
      box-shadow: 0 4px 10px var(--shadow);
    }

    .puzzle-tile.empty {
      background: rgba(255, 255, 255, 0.3);
      cursor: default;
    }

    .puzzle-tile.solved {
      animation: lockIn 0.3s ease;
    }

    @keyframes lockIn {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .puzzle-controls {
      margin-top: 20px;
    }

    .puzzle-image-upload {
      margin-bottom: 20px;
    }

    .upload-btn {
      background: var(--pink-accent);
      color: white;
      padding: 10px 20px;
      border-radius: 25px;
      border: none;
      cursor: pointer;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
    }

    .upload-btn:hover {
      background: var(--pink-dark);
    }

    /* ============= FINAL SCENE ============= */
    .final-glow {
      animation: glow 2s ease-in-out infinite;
    }

    @keyframes glow {
      0%, 100% {
        box-shadow: 0 0 20px var(--pink-accent),
                    0 0 40px var(--pink-accent),
                    0 0 60px var(--pink-accent);
      }
      50% {
        box-shadow: 0 0 30px var(--pink-accent),
                    0 0 60px var(--pink-accent),
                    0 0 90px var(--pink-accent);
      }
    }

    /* ============= RESPONSIVE ============= */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }

      p {
        font-size: 1rem;
      }

      .scene-content {
        padding: 30px 20px;
      }

      .game-container {
        height: 400px;
      }

      .maze {
        grid-template-columns: repeat(10, 1fr);
      }

      .puzzle-container {
        max-width: 320px;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.5rem;
      }

      .btn {
        padding: 12px 30px;
        font-size: 1rem;
      }

      .music-toggle {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
    }

    /* Hide scrollbar but keep functionality */
    body::-webkit-scrollbar {
      display: none;
    }
    body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
  </style>
</head>
<body>

  <!-- Floating Hearts Background -->
  <div class="floating-hearts" id="floatingHearts"></div>

  <!-- Music Toggle -->
  <button class="music-toggle" id="musicToggle" aria-label="Toggle music">
    üîä
  </button>

  <!-- Background Music -->
  <audio id="bgMusic" loop>
    <source src="ordinary.mp3" type="audio/mpeg">
  </audio>

  <!-- ===================== SCENE 1: Initial Ask ===================== -->
  <div class="scene active" id="scene1">
    <div class="scene-content">
      <h1>üíù Will you be my Valentine? üíù</h1>
      <p>Choose wisely... üòä</p>
      <div style="position: relative; height: 80px;">
        <button class="btn btn-yes" id="yesBtn1">Yes üíñ</button>
        <button class="btn btn-no" id="noBtn">No üôà</button>
      </div>
      <div class="playful-message" id="playfulMessage"></div>
    </div>
  </div>

  <!-- ===================== SCENE 2: Maze Game ===================== -->
  <div class="scene" id="scene2">
    <div class="scene-content" style="max-width: 700px;">
      <h1>üåπ Find Your Way to Me üåπ</h1>
      <p>Navigate the heart through the maze to reach ME!</p>
      <div class="maze-container" id="mazeContainer">
        <div class="maze" id="maze"></div>
      </div>
      <div class="controls-hint">Use Arrow Keys or Swipe (Mobile)</div>
    </div>
  </div>

  <!-- ===================== SCENE 3: Heart Catcher ===================== -->
  <div class="scene" id="scene3">
    <div class="scene-content" style="max-width: 700px;">
      <h1>üíï Catch the Hearts! üíï</h1>
      <p>Catch as many hearts as you can!</p>
      <div class="game-stats">
        <div>Score: <span id="score">0</span></div>
        <div>Time: <span id="timer">120</span>s</div>
      </div>
      <div class="game-container" id="gameContainer">
        <div class="basket" id="basket">üß∫</div>
      </div>
      <div class="controls-hint">Use Arrow Keys or Drag (Mobile)</div>
    </div>
  </div>

  <!-- ===================== SCENE 4: Puzzle Game ===================== -->
  <div class="scene" id="scene4">
    <div class="scene-content">
      <h1>üß© Complete Our Picture üß©</h1>
      <p>Solve the puzzle to reveal our special moment!</p>
      
      <div class="puzzle-image-upload">
        <input type="file" id="puzzleImageInput" accept="image/*" style="display: none;">
        <button class="upload-btn" onclick="document.getElementById('puzzleImageInput').click()">
          üì∑ Upload Your Image
        </button>
        <div id="imageStatus" style="margin-top: 10px; font-size: 0.9rem;"></div>
      </div>

      <div class="puzzle-container" id="puzzleContainer"></div>
      
      <div class="puzzle-controls">
        <button class="btn btn-yes" onclick="shufflePuzzle()">üîÄ Shuffle</button>
        <button class="btn btn-yes" onclick="resetPuzzle()">üîÑ Reset</button>
      </div>
      
      <div style="margin-top: 15px; font-size: 0.9rem; opacity: 0.7;">
        Click tiles adjacent to the empty space to move them
      </div>
    </div>
  </div>

  <!-- ===================== FINAL SCENE ===================== -->
  <div class="scene" id="sceneFinal">
    <div class="scene-content final-glow">
      <h1>üíñ One More Time... üíñ</h1>
      <p>So... will you be my Valentine?</p>
      <button class="btn btn-yes" id="finalYesBtn">Yes. Obviously. üíï</button>
    </div>
  </div>

  <script>
    // ============= GLOBAL VARIABLES & UTILITIES =============
    let currentScene = 1;
    let musicPlaying = false;
    const bgMusic = document.getElementById('bgMusic');
    const musicToggle = document.getElementById('musicToggle');

    // Music Control
    musicToggle.addEventListener('click', () => {
      if (musicPlaying) {
        bgMusic.pause();
        musicToggle.textContent = 'üîá';
        musicPlaying = false;
      } else {
        bgMusic.play().catch(e => console.log('Autoplay prevented'));
        musicToggle.textContent = 'üîä';
        musicPlaying = true;
      }
    });

    // Try to autoplay (may be blocked by browser)
    document.addEventListener('click', () => {
      if (!musicPlaying) {
        bgMusic.play().then(() => {
          musicPlaying = true;
          musicToggle.textContent = 'üîä';
        }).catch(() => {});
      }
    }, { once: true });

    // Floating Hearts Background
    function createFloatingHeart() {
      const heart = document.createElement('div');
      heart.className = 'floating-heart';
      heart.textContent = ['‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'üíù'][Math.floor(Math.random() * 5)];
      heart.style.left = Math.random() * 100 + 'vw';
      heart.style.animationDuration = (Math.random() * 5 + 8) + 's';
      heart.style.fontSize = (Math.random() * 15 + 15) + 'px';
      document.getElementById('floatingHearts').appendChild(heart);
      
      setTimeout(() => heart.remove(), 13000);
    }

    setInterval(createFloatingHeart, 500);

    // Scene Transition
    function goToScene(sceneNumber) {
      document.querySelectorAll('.scene').forEach(scene => {
        scene.classList.remove('active');
      });
      
      setTimeout(() => {
        document.getElementById(`scene${sceneNumber}`).classList.add('active');
        currentScene = sceneNumber;
      }, 100);
    }

    // Confetti Function
    function triggerConfetti() {
      confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#FFB3C6', '#FF8FAB', '#FF6B9D']
      });
    }

    // ============= SCENE 1: INITIAL ASK =============
    const noBtn = document.getElementById('noBtn');
    const yesBtn1 = document.getElementById('yesBtn1');
    const playfulMessage = document.getElementById('playfulMessage');
    let noClickCount = 0;

    const playfulMessages = [
      "Nice try... üòè",
      "That's illegal! üö´",
      "Are you sure about that? ü§î",
      "Really? Come on... üíï",
      "Last chance! üò§",
      "Okay, enough games! Time to prove it! üí™"
    ];

    function moveNoButton() {
      const container = noBtn.parentElement;
      const containerRect = container.getBoundingClientRect();
      const btnRect = noBtn.getBoundingClientRect();
      
      const maxX = containerRect.width - btnRect.width - 20;
      const maxY = containerRect.height - btnRect.height - 20;
      
      const newX = Math.random() * maxX;
      const newY = Math.random() * maxY;
      
      noBtn.style.left = newX + 'px';
      noBtn.style.top = newY + 'px';
      
      noClickCount++;
      
      if (noClickCount < playfulMessages.length) {
        playfulMessage.textContent = playfulMessages[noClickCount - 1];
      }
      
      if (noClickCount >= 5) {
        setTimeout(() => {
          playfulMessage.textContent = "Took you long enough. Now prove it! üíï";
          setTimeout(() => {
            triggerConfetti();
            goToScene(2);
            initMaze();
          }, 2000);
        }, 500);
      }
    }

    noBtn.addEventListener('mouseenter', moveNoButton);
    noBtn.addEventListener('click', moveNoButton);

    // Touch support for mobile
    noBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      moveNoButton();
    });

    yesBtn1.addEventListener('click', () => {
      triggerConfetti();
      playfulMessage.textContent = "Perfect! Let's continue... üíñ";
      setTimeout(() => {
        goToScene(2);
        initMaze();
      }, 1500);
    });

    // ============= SCENE 2: MAZE GAME =============
    let mazeGrid = [];
    let playerPos = { row: 0, col: 0 };
    let goalPos = { row: 9, col: 9 };
    let mazeMessage = null;

    const mazeMessages = [
      "Please find your love soon üíï",
      "Do you not want to come to me? ü•∫",
      "Come soon, I'm waiting! üíñ",
      "Wrong way, silly! üòä",
      "I'm over here! üëã"
    ];

    function createMaze() {
      // Simple maze pattern (0 = wall, 1 = path)
      const pattern = [
        [1,1,1,0,1,1,1,1,1,1],
        [0,0,1,0,1,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,1,0,1],
        [1,1,1,1,1,1,0,1,1,1],
        [0,0,0,0,0,1,0,0,0,1],
        [1,1,1,1,1,1,1,1,0,1],
        [1,0,0,0,0,0,0,1,0,1],
        [1,1,1,1,1,1,0,1,1,1],
        [0,0,0,0,0,1,1,1,0,1]
      ];
      return pattern;
    }

    function initMaze() {
      mazeGrid = createMaze();
      playerPos = { row: 0, col: 0 };
      renderMaze();
    }

    function renderMaze() {
      const mazeContainer = document.getElementById('maze');
      mazeContainer.innerHTML = '';
      
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 10; col++) {
          const cell = document.createElement('div');
          cell.className = 'maze-cell';
          
          if (mazeGrid[row][col] === 0) {
            cell.classList.add('wall');
          } else {
            cell.classList.add('path');
          }
          
          if (row === playerPos.row && col === playerPos.col) {
            cell.classList.add('player');
            cell.textContent = '‚ù§Ô∏è';
          }
          
          if (row === goalPos.row && col === goalPos.col) {
            cell.classList.add('goal');
            cell.textContent = 'ME';
          }
          
          mazeContainer.appendChild(cell);
        }
      }
    }

    function movePlayer(rowDelta, colDelta) {
      const newRow = playerPos.row + rowDelta;
      const newCol = playerPos.col + colDelta;
      
      if (newRow < 0 || newRow >= 10 || newCol < 0 || newCol >= 10) {
        return;
      }
      
      if (mazeGrid[newRow][newCol] === 0) {
        showMazeMessage();
        return;
      }
      
      playerPos.row = newRow;
      playerPos.col = newCol;
      renderMaze();
      
      if (playerPos.row === goalPos.row && playerPos.col === goalPos.col) {
        setTimeout(() => {
          triggerConfetti();
          const messageDiv = document.createElement('div');
          messageDiv.style.position = 'fixed';
          messageDiv.style.top = '50%';
          messageDiv.style.left = '50%';
          messageDiv.style.transform = 'translate(-50%, -50%)';
          messageDiv.style.background = 'rgba(255, 255, 255, 0.95)';
          messageDiv.style.padding = '30px';
          messageDiv.style.borderRadius = '20px';
          messageDiv.style.fontSize = '1.5rem';
          messageDiv.style.fontWeight = '600';
          messageDiv.style.color = 'var(--pink-accent)';
          messageDiv.style.zIndex = '1000';
          messageDiv.style.boxShadow = '0 10px 40px rgba(0,0,0,0.3)';
          messageDiv.textContent = 'üíï You always find your way back to me! üíï';
          document.body.appendChild(messageDiv);
          
          setTimeout(() => {
            messageDiv.remove();
            goToScene(3);
            initHeartCatcher();
          }, 2500);
        }, 300);
      }
    }

    function showMazeMessage() {
      if (mazeMessage) {
        mazeMessage.remove();
      }
      
      const container = document.getElementById('mazeContainer');
      mazeMessage = document.createElement('div');
      mazeMessage.className = 'maze-message';
      mazeMessage.textContent = mazeMessages[Math.floor(Math.random() * mazeMessages.length)];
      container.appendChild(mazeMessage);
      
      setTimeout(() => {
        if (mazeMessage) {
          mazeMessage.remove();
          mazeMessage = null;
        }
      }, 2000);
    }

    // Maze keyboard controls
    document.addEventListener('keydown', (e) => {
      if (currentScene !== 2) return;
      
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          movePlayer(-1, 0);
          break;
        case 'ArrowDown':
          e.preventDefault();
          movePlayer(1, 0);
          break;
        case 'ArrowLeft':
          e.preventDefault();
          movePlayer(0, -1);
          break;
        case 'ArrowRight':
          e.preventDefault();
          movePlayer(0, 1);
          break;
      }
    });

    // Maze touch controls
    let touchStartX = 0;
    let touchStartY = 0;

    document.addEventListener('touchstart', (e) => {
      if (currentScene !== 2) return;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });

    document.addEventListener('touchend', (e) => {
      if (currentScene !== 2) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 30) movePlayer(0, 1);
        else if (deltaX < -30) movePlayer(0, -1);
      } else {
        if (deltaY > 30) movePlayer(1, 0);
        else if (deltaY < -30) movePlayer(-1, 0);
      }
    });

    // ============= SCENE 3: HEART CATCHER GAME =============
    let score = 0;
    let timeLeft = 10;
    let gameInterval = null;
    let timerInterval = null;
    let basketPosition = 50; // percentage

    function initHeartCatcher() {
      score = 0;
      timeLeft = 10;
      basketPosition = 50;
      
      document.getElementById('score').textContent = score;
      document.getElementById('timer').textContent = timeLeft;
      document.getElementById('basket').style.left = basketPosition + '%';
      
      // Clear any existing hearts
      document.querySelectorAll('.falling-heart').forEach(h => h.remove());
      
      // Start spawning hearts
      gameInterval = setInterval(spawnHeart, 400);
      
      // Start timer
      timerInterval = setInterval(() => {
        timeLeft--;
        document.getElementById('timer').textContent = timeLeft;
        
        if (timeLeft <= 0) {
          endHeartCatcher();
        }
      }, 1000);
    }

    function spawnHeart() {
      const container = document.getElementById('gameContainer');
      const heart = document.createElement('div');
      heart.className = 'falling-heart';
      
      const types = [
        { emoji: '‚ù§Ô∏è', points: 1, prob: 0.4 },
        { emoji: 'üíõ', points: 3, prob: 0.3 },
        { emoji: 'üíî', points: -2, prob: 0.3 }
      ];
      
      const rand = Math.random();
      let cumProb = 0;
      let selectedType = types[0];
      
      for (let type of types) {
        cumProb += type.prob;
        if (rand <= cumProb) {
          selectedType = type;
          break;
        }
      }
      
      heart.textContent = selectedType.emoji;
      heart.dataset.points = selectedType.points;
      heart.style.left = Math.random() * 90 + '%';
      heart.style.animationDuration = (Math.random() * 2 + 3) + 's';
      
      container.appendChild(heart);
      
      // Check collision during fall
      const checkCollision = setInterval(() => {
        const heartRect = heart.getBoundingClientRect();
        const basketRect = document.getElementById('basket').getBoundingClientRect();
        
        if (heartRect.bottom >= basketRect.top &&
            heartRect.top <= basketRect.bottom &&
            heartRect.right >= basketRect.left &&
            heartRect.left <= basketRect.right) {
          score += parseInt(heart.dataset.points);
          document.getElementById('score').textContent = score;
          heart.remove();
          clearInterval(checkCollision);
          
          // Visual feedback
          if (parseInt(heart.dataset.points) > 0) {
            triggerConfetti();
          }
        }
      }, 50);
      
      setTimeout(() => {
        heart.remove();
        clearInterval(checkCollision);
      }, 6000);
    }

    function moveBasket(direction) {
      if (direction === 'left') {
        basketPosition = Math.max(0, basketPosition - 5);
      } else {
        basketPosition = Math.min(92, basketPosition + 5);
      }
      document.getElementById('basket').style.left = basketPosition + '%';
    }

    // Basket keyboard controls
    document.addEventListener('keydown', (e) => {
      if (currentScene !== 3) return;
      
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        moveBasket('left');
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        moveBasket('right');
      }
    });

    // Basket touch drag
    let basketDragging = false;

    document.getElementById('basket').addEventListener('touchstart', (e) => {
      basketDragging = true;
    });

    document.addEventListener('touchmove', (e) => {
      if (!basketDragging || currentScene !== 3) return;
      
      const container = document.getElementById('gameContainer');
      const containerRect = container.getBoundingClientRect();
      const touchX = e.touches[0].clientX;
      const relativeX = touchX - containerRect.left;
      basketPosition = (relativeX / containerRect.width) * 100;
      basketPosition = Math.max(0, Math.min(92, basketPosition));
      document.getElementById('basket').style.left = basketPosition + '%';
    });

    document.addEventListener('touchend', () => {
      basketDragging = false;
    });

    function endHeartCatcher() {
      clearInterval(gameInterval);
      clearInterval(timerInterval);
      
      document.querySelectorAll('.falling-heart').forEach(h => h.remove());
      
      const prize = score * 10;
      
      triggerConfetti();
      
      const messageDiv = document.createElement('div');
      messageDiv.style.position = 'fixed';
      messageDiv.style.top = '50%';
      messageDiv.style.left = '50%';
      messageDiv.style.transform = 'translate(-50%, -50%)';
      messageDiv.style.background = 'rgba(255, 255, 255, 0.98)';
      messageDiv.style.padding = '40px';
      messageDiv.style.borderRadius = '25px';
      messageDiv.style.fontSize = '1.3rem';
      messageDiv.style.fontWeight = '600';
      messageDiv.style.color = 'var(--pink-accent)';
      messageDiv.style.zIndex = '1000';
      messageDiv.style.boxShadow = '0 15px 50px rgba(0,0,0,0.3)';
      messageDiv.style.textAlign = 'center';
      messageDiv.style.maxWidth = '500px';
      messageDiv.innerHTML = `
        <div style="font-size: 2rem; margin-bottom: 15px;">üéâ</div>
        <div>You caught <strong>${score}</strong> hearts!</div>
        <div style="margin-top: 15px;">That's ${score} reasons I want you as my Valentine.</div>
        <div style="margin-top: 15px; font-size: 1.1rem;">
          I'd like to give you <strong>$${prize}</strong> to spoil yourself! üíù
        </div>
      `;
      document.body.appendChild(messageDiv);
      
      setTimeout(() => {
        messageDiv.remove();
        goToScene(4);
        initPuzzle();
      }, 4500);
    }

    // ============= SCENE 4: PUZZLE GAME =============
    // let puzzleTiles = [];
    // let emptyPos = { row: 3, col: 3 };
    // let puzzleImage = null;
    // const PUZZLE_SIZE = 4;

    // // Default image (placeholder)
    // const defaultPuzzleImage = 'our-image.jpg';

    // document.getElementById('puzzleImageInput').addEventListener('change', (e) => {
    //   const file = e.target.files[0];
    //   if (file) {
    //     const reader = new FileReader();
    //     reader.onload = (event) => {
    //       puzzleImage = event.target.result;
    //       document.getElementById('imageStatus').textContent = '‚úì Image uploaded!';
    //       document.getElementById('imageStatus').style.color = 'var(--pink-accent)';
    //       initPuzzle();
    //     };
    //     reader.readAsDataURL(file);
    //   }
    // });

    // function initPuzzle() {
    //   if (!puzzleImage) {
    //     puzzleImage = defaultPuzzleImage;
    //   }
      
    //   const container = document.getElementById('puzzleContainer');
    //   container.innerHTML = '';
    //   puzzleTiles = [];
    //   emptyPos = { row: PUZZLE_SIZE - 1, col: PUZZLE_SIZE - 1 };
      
    //   for (let row = 0; row < PUZZLE_SIZE; row++) {
    //     puzzleTiles[row] = [];
    //     for (let col = 0; col < PUZZLE_SIZE; col++) {
    //       const tile = document.createElement('div');
    //       tile.className = 'puzzle-tile';
    //       tile.dataset.row = row;
    //       tile.dataset.col = col;
    //       tile.dataset.originalRow = row;
    //       tile.dataset.originalCol = col;
          
    //       if (row === PUZZLE_SIZE - 1 && col === PUZZLE_SIZE - 1) {
    //         tile.classList.add('empty');
    //       } else {
    //         const bgPosX = (col / (PUZZLE_SIZE - 1)) * 100;
    //         const bgPosY = (row / (PUZZLE_SIZE - 1)) * 100;
    //         tile.style.backgroundImage = `url(${puzzleImage})`;
    //         tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;
    //       }
          
    //       tile.addEventListener('click', () => movePuzzleTile(row, col));
    //       container.appendChild(tile);
    //       puzzleTiles[row][col] = tile;
    //     }
    //   }
      
    //   setTimeout(() => shufflePuzzle(), 500);
    // }

    // function movePuzzleTile(row, col) {
    //   const rowDiff = Math.abs(row - emptyPos.row);
    //   const colDiff = Math.abs(col - emptyPos.col);
      
    //   if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
    //     const clickedTile = puzzleTiles[row][col];
    //     const emptyTile = puzzleTiles[emptyPos.row][emptyPos.col];
        
    //     // Swap visual properties
    //     const tempBg = clickedTile.style.backgroundImage;
    //     const tempBgPos = clickedTile.style.backgroundPosition;
    //     const tempOrigRow = clickedTile.dataset.originalRow;
    //     const tempOrigCol = clickedTile.dataset.originalCol;
        
    //     clickedTile.style.backgroundImage = '';
    //     clickedTile.style.backgroundPosition = '';
    //     clickedTile.classList.add('empty');
    //     clickedTile.dataset.originalRow = emptyTile.dataset.originalRow;
    //     clickedTile.dataset.originalCol = emptyTile.dataset.originalCol;
        
    //     emptyTile.style.backgroundImage = tempBg;
    //     emptyTile.style.backgroundPosition = tempBgPos;
    //     emptyTile.classList.remove('empty');
    //     emptyTile.dataset.originalRow = tempOrigRow;
    //     emptyTile.dataset.originalCol = tempOrigCol;
        
    //     // Swap in array
    //     puzzleTiles[row][col] = emptyTile;
    //     puzzleTiles[emptyPos.row][emptyPos.col] = clickedTile;
        
    //     emptyPos = { row, col };
        
    //     checkPuzzleSolved();
    //   }
    // }

    // function shufflePuzzle() {
    //   for (let i = 0; i < 100; i++) {
    //     const validMoves = [];
        
    //     if (emptyPos.row > 0) validMoves.push({ row: emptyPos.row - 1, col: emptyPos.col });
    //     if (emptyPos.row < PUZZLE_SIZE - 1) validMoves.push({ row: emptyPos.row + 1, col: emptyPos.col });
    //     if (emptyPos.col > 0) validMoves.push({ row: emptyPos.row, col: emptyPos.col - 1 });
    //     if (emptyPos.col < PUZZLE_SIZE - 1) validMoves.push({ row: emptyPos.row, col: emptyPos.col + 1 });
        
    //     const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
    //     movePuzzleTile(randomMove.row, randomMove.col);
    //   }
    // }

    // function resetPuzzle() {
    //   initPuzzle();
    // }

    // function checkPuzzleSolved() {
    //   let solved = true;
      
    //   for (let row = 0; row < PUZZLE_SIZE; row++) {
    //     for (let col = 0; col < PUZZLE_SIZE; col++) {
    //       const tile = puzzleTiles[row][col];
    //       if (parseInt(tile.dataset.originalRow) !== row || 
    //           parseInt(tile.dataset.originalCol) !== col) {
    //         solved = false;
    //         break;
    //       }
    //     }
    //     if (!solved) break;
    //   }
      
    //   if (solved) {
    //     // Add solved animation
    //     document.querySelectorAll('.puzzle-tile').forEach(tile => {
    //       tile.classList.add('solved');
    //     });
        
    //     // Show full image
    //     setTimeout(() => {
    //       document.querySelectorAll('.puzzle-tile.empty').forEach(tile => {
    //         tile.classList.remove('empty');
    //         const row = parseInt(tile.dataset.row);
    //         const col = parseInt(tile.dataset.col);
    //         const bgPosX = (col / (PUZZLE_SIZE - 1)) * 100;
    //         const bgPosY = (row / (PUZZLE_SIZE - 1)) * 100;
    //         tile.style.backgroundImage = `url(${puzzleImage})`;
    //         tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;
    //       });
    //     }, 300);
        
    //     triggerConfetti();
        
    //     const messageDiv = document.createElement('div');
    //     messageDiv.style.position = 'fixed';
    //     messageDiv.style.top = '50%';
    //     messageDiv.style.left = '50%';
    //     messageDiv.style.transform = 'translate(-50%, -50%)';
    //     messageDiv.style.background = 'rgba(255, 255, 255, 0.98)';
    //     messageDiv.style.padding = '40px';
    //     messageDiv.style.borderRadius = '25px';
    //     messageDiv.style.fontSize = '1.5rem';
    //     messageDiv.style.fontWeight = '600';
    //     messageDiv.style.color = 'var(--pink-accent)';
    //     messageDiv.style.zIndex = '1000';
    //     messageDiv.style.boxShadow = '0 15px 50px rgba(0,0,0,0.3)';
    //     messageDiv.style.textAlign = 'center';
    //     messageDiv.innerHTML = `
    //       <div style="font-size: 2.5rem; margin-bottom: 15px;">üíï</div>
    //       <div>You put us back together perfectly!</div>
    //     `;
    //     document.body.appendChild(messageDiv);
        
    //     setTimeout(() => {
    //       messageDiv.remove();
    //       goToScene('Final');
    //     }, 3000);
    //   }
    // }
    // ============= SCENE 4: PUZZLE GAME =============
    let puzzleTiles = [];
    let emptyPos = { row: 3, col: 3 };
    let puzzleImage = null;
    const PUZZLE_SIZE = 4;
    
    // Default image from your repo
    const defaultPuzzleImage = 'our-image.jpg';
    
    // Image upload (optional override)
    document.getElementById('puzzleImageInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          puzzleImage = event.target.result;
          document.getElementById('imageStatus').textContent = '‚úì Image uploaded!';
          document.getElementById('imageStatus').style.color = 'var(--pink-accent)';
          initPuzzle();
        };
        reader.readAsDataURL(file);
      }
    });
    
    function initPuzzle() {
      if (!puzzleImage) {
        puzzleImage = defaultPuzzleImage;
      }
    
      const container = document.getElementById('puzzleContainer');
      container.innerHTML = '';
      puzzleTiles = [];
      emptyPos = { row: PUZZLE_SIZE - 1, col: PUZZLE_SIZE - 1 };
    
      for (let row = 0; row < PUZZLE_SIZE; row++) {
        puzzleTiles[row] = [];
        for (let col = 0; col < PUZZLE_SIZE; col++) {
          const tile = document.createElement('div');
          tile.className = 'puzzle-tile';
          tile.dataset.row = row;
          tile.dataset.col = col;
          tile.dataset.originalRow = row;
          tile.dataset.originalCol = col;
    
          if (row === PUZZLE_SIZE - 1 && col === PUZZLE_SIZE - 1) {
            tile.classList.add('empty');
          } else {
            const bgPosX = (col / (PUZZLE_SIZE - 1)) * 100;
            const bgPosY = (row / (PUZZLE_SIZE - 1)) * 100;
    
            tile.style.backgroundImage = `url(${puzzleImage})`;
            tile.style.backgroundSize = `${PUZZLE_SIZE * 100}% ${PUZZLE_SIZE * 100}%`;
            tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;
          }
    
          tile.addEventListener('click', () => movePuzzleTile(row, col));
          container.appendChild(tile);
          puzzleTiles[row][col] = tile;
        }
      }
    
      setTimeout(() => shufflePuzzle(), 500);
    }
    
    function movePuzzleTile(row, col) {
      const rowDiff = Math.abs(row - emptyPos.row);
      const colDiff = Math.abs(col - emptyPos.col);
    
      if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
        const clickedTile = puzzleTiles[row][col];
        const emptyTile = puzzleTiles[emptyPos.row][emptyPos.col];
    
        // Swap visuals
        emptyTile.style.backgroundImage = clickedTile.style.backgroundImage;
        emptyTile.style.backgroundPosition = clickedTile.style.backgroundPosition;
        emptyTile.style.backgroundSize = clickedTile.style.backgroundSize;
        emptyTile.classList.remove('empty');
    
        clickedTile.style.backgroundImage = '';
        clickedTile.style.backgroundPosition = '';
        clickedTile.style.backgroundSize = '';
        clickedTile.classList.add('empty');
    
        // Swap original tracking
        const tempRow = clickedTile.dataset.originalRow;
        const tempCol = clickedTile.dataset.originalCol;
    
        clickedTile.dataset.originalRow = emptyTile.dataset.originalRow;
        clickedTile.dataset.originalCol = emptyTile.dataset.originalCol;
    
        emptyTile.dataset.originalRow = tempRow;
        emptyTile.dataset.originalCol = tempCol;
    
        puzzleTiles[row][col] = emptyTile;
        puzzleTiles[emptyPos.row][emptyPos.col] = clickedTile;
    
        emptyPos = { row, col };
    
        checkPuzzleSolved();
      }
    }
    
    function shufflePuzzle() {
      for (let i = 0; i < 150; i++) {
        const validMoves = [];
    
        if (emptyPos.row > 0) validMoves.push({ row: emptyPos.row - 1, col: emptyPos.col });
        if (emptyPos.row < PUZZLE_SIZE - 1) validMoves.push({ row: emptyPos.row + 1, col: emptyPos.col });
        if (emptyPos.col > 0) validMoves.push({ row: emptyPos.row, col: emptyPos.col - 1 });
        if (emptyPos.col < PUZZLE_SIZE - 1) validMoves.push({ row: emptyPos.row, col: emptyPos.col + 1 });
    
        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
        movePuzzleTile(randomMove.row, randomMove.col);
      }
    }
    
    function resetPuzzle() {
      initPuzzle();
    }
    
    function checkPuzzleSolved() {
      let solved = true;
    
      for (let row = 0; row < PUZZLE_SIZE; row++) {
        for (let col = 0; col < PUZZLE_SIZE; col++) {
          const tile = puzzleTiles[row][col];
          if (
            parseInt(tile.dataset.originalRow) !== row ||
            parseInt(tile.dataset.originalCol) !== col
          ) {
            solved = false;
            break;
          }
        }
        if (!solved) break;
      }
    
      if (solved) {
        document.querySelectorAll('.puzzle-tile').forEach(tile => {
          tile.classList.add('solved');
        });
    
        triggerConfetti();
    
        const messageDiv = document.createElement('div');
        messageDiv.style.position = 'fixed';
        messageDiv.style.top = '50%';
        messageDiv.style.left = '50%';
        messageDiv.style.transform = 'translate(-50%, -50%)';
        messageDiv.style.background = 'rgba(255, 255, 255, 0.98)';
        messageDiv.style.padding = '40px';
        messageDiv.style.borderRadius = '25px';
        messageDiv.style.fontSize = '1.5rem';
        messageDiv.style.fontWeight = '600';
        messageDiv.style.color = 'var(--pink-accent)';
        messageDiv.style.zIndex = '1000';
        messageDiv.style.boxShadow = '0 15px 50px rgba(0,0,0,0.3)';
        messageDiv.style.textAlign = 'center';
        messageDiv.innerHTML = `
          <div style="font-size: 2.5rem; margin-bottom: 15px;">üíï</div>
          <div>You put us back together perfectly!</div>
        `;
        document.body.appendChild(messageDiv);
    
        setTimeout(() => {
          messageDiv.remove();
          goToScene('Final');
        }, 3000);
      }
    }

    // ============= FINAL SCENE =============
    document.getElementById('finalYesBtn').addEventListener('click', () => {
      // Massive confetti
      const duration = 4000;
      const end = Date.now() + duration;

      (function frame() {
        confetti({
          particleCount: 5,
          angle: 60,
          spread: 55,
          origin: { x: 0 },
          colors: ['#FFB3C6', '#FF8FAB', '#FF6B9D']
        });
        confetti({
          particleCount: 5,
          angle: 120,
          spread: 55,
          origin: { x: 1 },
          colors: ['#FFB3C6', '#FF8FAB', '#FF6B9D']
        });

        if (Date.now() < end) {
          requestAnimationFrame(frame);
        }
      }());
      
      const finalMsg = document.createElement('div');
      finalMsg.style.position = 'fixed';
      finalMsg.style.top = '50%';
      finalMsg.style.left = '50%';
      finalMsg.style.transform = 'translate(-50%, -50%)';
      finalMsg.style.background = 'rgba(255, 255, 255, 0.98)';
      finalMsg.style.padding = '50px';
      finalMsg.style.borderRadius = '30px';
      finalMsg.style.fontSize = '2rem';
      finalMsg.style.fontWeight = '700';
      finalMsg.style.color = 'var(--pink-accent)';
      finalMsg.style.zIndex = '1001';
      finalMsg.style.boxShadow = '0 20px 60px rgba(0,0,0,0.4)';
      finalMsg.style.textAlign = 'center';
      finalMsg.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 20px;">üíñ</div>
        <div>Best decision ever!</div>
        <div style="font-size: 1.2rem; margin-top: 20px; font-weight: 400;">
          Happy Valentine's Day! üíï
        </div>
      `;
      document.body.appendChild(finalMsg);
    });

    // Prevent scroll on arrow keys
    window.addEventListener('keydown', (e) => {
      if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
      }
    });
  </script>

</body>
</html>
